https://rustwasm.github.io/book/game-of-life/introduction.html

Javascript stores objects, arrays and DOM nodes in a GC heap. Our rust values live in the wasm linear space. Wasm cannot access the heap, but JS can read/write to wasm memory but only using scalar(u8, i32, f64, etc...) values. Wasm functions also take and return scalar values. As for as compound data structures go, wasm_bindgen helps us define interfaces to handle them. wasm_bindgen helps us define and work with opaque handles to JavaScript Objects or boxed Rust structures. A good interface design in such case is one where JS calls wasm fuctions that take those handles, perform all computations and then return a small copyable result back to JS. This way, a lot of unnecessary communication between JS's heap and wasm linear space is avoided.

The cells of the universe are stored as a linear bool array.

This project uses node 16.15.1, so used nvm to set it to this version. All this nvm/npm stuff is to be done only in the www folder.
Before running 'npm run start', type 'nvm use 16.15.1'. This loads up localhost. Anytime you make changes and want them reflected on http://localhost:8080/, just re-run the 'wasm-pack build' command within the wasm-game-of-life directory.


Future work:
Initialize with a spaceship, DONE
Random initialization of the universe, DONE, cargo add rand, and use a random_bool closure
Use a single bit for each cell rather than byte, To-be-done
1. using hashlife to get exponentially faster computations
